<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Agent F√°bio: O Tira da Gurizada</title>
    <!-- Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts for "Inter" -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Base styles for the body and game container */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            color: #e2e8f0; /* Light text color */
        }
        /* Canvas styling */
        canvas {
            border: 2px solid #4a5568; /* Border for the game area */
            background-color: #2d3748; /* Background inside canvas */
            border-radius: 0.5rem; /* Rounded corners for canvas */
            display: block; /* Ensures canvas takes full width */
            margin: 0 auto; /* Centers the canvas horizontally */
        }
        /* Styling for the main game container (intro, game screen, game over) */
        .game-container {
            display: flex;
            flex-direction: column;
            gap: 1rem; /* Space between elements */
            align-items: center;
            padding: 1.5rem;
            background-color: #2d3748; /* Container background */
            border-radius: 0.75rem; /* Rounded corners */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); /* Soft shadow */
        }
        /* General button styling */
        .btn {
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s; /* Smooth transition for hover effects */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        /* Primary button color (e.g., difficulty selection) */
        .btn-primary {
            background-color: #667eea; /* Indigo */
            color: white;
        }
        .btn-primary:hover {
            background-color: #5a67d8; /* Darker indigo on hover */
            transform: translateY(-2px); /* Slight lift effect */
        }
        /* Danger button color (e.g., restart) */
        .btn-danger {
            background-color: #f56565; /* Red */
            color: white;
        }
        .btn-danger:hover {
            background-color: #e53e3e; /* Darker red on hover */
            transform: translateY(-2px); /* Slight lift effect */
        }
        /* Attack button styling */
        .attack-button {
            background-color: #48bb78; /* Green */
            color: white;
            display: flex; /* Use flexbox for button content */
            flex-direction: column; /* Stack text and progress bar */
            align-items: center;
            justify-content: center;
        }
        .attack-button:hover:not(:disabled) {
            background-color: #38a169; /* Darker green on hover */
        }
        .attack-button:disabled {
            background-color: #a0aec0; /* Grey when disabled */
            cursor: not-allowed; /* No-go cursor */
        }
        /* Styling for in-game messages */
        .message-box {
            background-color: #4a5568; /* Dark grey background */
            padding: 1rem;
            border-radius: 0.5rem;
            text-align: center;
            margin-top: 1rem;
        }
        /* Progress bar container for attack cooldowns */
        .progress-bar-container {
            width: 90%; /* Occupy most of the button width */
            background-color: #4a5568; /* Dark grey background */
            border-radius: 0.25rem;
            overflow: hidden; /* Hide overflow from the bar */
            height: 1rem;
            margin-top: 0.5rem;
        }
        /* Actual progress bar */
        .progress-bar {
            height: 100%;
            background-color: #48bb78; /* Green progress color */
            width: 0%; /* Starts at 0% width */
            transition: width 0.1s linear; /* Smooth transition for progress updates */
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 flex items-center justify-center min-h-screen p-4">

    <!-- Game Introduction Screen -->
    <div id="game-intro" class="game-container max-w-lg w-full text-center p-8 rounded-xl shadow-lg transition-all duration-300 ease-in-out">
        <h1 class="text-5xl font-extrabold mb-6 text-indigo-400">AGENT F√ÅBIO</h1>
        <p class="text-3xl font-semibold mb-8 text-gray-300">um tira da gurizada</p>
        <div class="space-y-4">
            <button id="difficulty-normal" class="btn btn-primary w-full text-2xl py-3">NORMAL</button>
            <button id="difficulty-media" class="btn btn-primary w-full text-2xl py-3">M√âDIA</button>
            <button id="difficulty-extremepower" class="btn btn-primary w-full text-2xl py-3">EXTREMEPOWER</button>
        </div>
    </div>

    <!-- Main Game Screen -->
    <div id="game-screen" class="game-container hidden max-w-4xl w-full p-6 rounded-xl transition-all duration-300 ease-in-out">
        <h2 class="text-3xl font-bold mb-4 text-indigo-400">Cidade Segura</h2>
        <div class="flex justify-between w-full mb-4 text-lg">
            <div id="player-health">HP F√°bio: 100</div>
            <div id="diamonds-remaining">Diamantes Restantes: 10</div>
            <div id="enemies-remaining">Ladr√µes Restantes: 5</div>
        </div>
        <canvas id="gameCanvas" width="800" height="600" class="rounded-lg shadow-inner"></canvas>

        <!-- Battle Screen (hidden by default) -->
        <div id="battle-screen" class="hidden w-full text-center p-4">
            <h3 class="text-2xl font-bold mb-4 text-red-400">Batalha!</h3>
            <div class="flex justify-around items-center mb-4">
                <div class="text-6xl">üëÆ</div> <!-- F√°bio Agent emoji -->
                <div class="text-4xl text-gray-400">VS</div>
                <div class="text-6xl" id="battle-enemy-emoji">ü¶π</div> <!-- Enemy emoji -->
            </div>
            <div id="enemy-battle-info" class="mb-4 text-xl">Ladr√£o HP: 10</div>
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 w-full">
                <!-- Drone Attack Buttons -->
                <button id="attack-vrombulha" class="btn attack-button text-xl py-3">
                    Vrombulha (1 DMG, 1s)
                    <div class="progress-bar-container"><div id="pb-vrombulha" class="progress-bar"></div></div>
                </button>
                <button id="attack-oinikmask" class="btn attack-button text-xl py-3">
                    Oinikmask (3 DMG, 3s)
                    <div class="progress-bar-container"><div id="pb-oinikmask" class="progress-bar"></div></div>
                </button>
                <button id="attack-niuciiii" class="btn attack-button text-xl py-3">
                    Niuciiii (15 DMG, 10s)
                    <div class="progress-bar-container"><div id="pb-niuciiii" class="progress-bar"></div></div>
                </button>
            </div>
            <div id="battle-message" class="message-box mt-4 text-lg hidden"></div>
        </div>
        <div id="game-message" class="message-box mt-4 text-lg hidden"></div>
        <button id="restart-button" class="btn btn-danger mt-6 hidden">Reiniciar Jogo</button>
    </div>

    <!-- Game Over / Win Screen -->
    <div id="game-over-screen" class="game-container hidden max-w-md w-full text-center p-8 rounded-xl shadow-lg">
        <h1 id="game-over-title" class="text-5xl font-extrabold mb-6 text-red-500">GAME OVER!</h1>
        <p id="game-over-message" class="text-2xl mb-8 text-gray-300">Os ladr√µes levaram todos os diamantes!</p>
        <button id="game-over-restart" class="btn btn-danger w-full text-xl py-3">Jogar Novamente</button>
    </div>

    <script>
        // Game Constants
        const TILE_SIZE = 40; // Tamanho de cada tile em pixels
        const MAP_WIDTH = 20; // Largura do mapa em tiles
        const MAP_HEIGHT = 15; // Altura do mapa em tiles
        const CANVAS_WIDTH = MAP_WIDTH * TILE_SIZE;
        const CANVAS_HEIGHT = MAP_HEIGHT * TILE_SIZE;

        const PLAYER_SPEED_MS = 150; // Atraso em milissegundos entre os movimentos do jogador
        const ENEMY_BASE_MOVE_DELAY_MS = 300; // Atraso base de movimento do ladr√£o
        const ENEMY_SPEED_FACTOR_NORMAL = 1; // Fator de velocidade para dificuldade Normal
        const ENEMY_SPEED_FACTOR_MEDIA = 0.5; // Fator de velocidade para dificuldade M√©dia (2x mais r√°pido)
        const ENEMY_SPEED_FACTOR_EXTREMEPOWER = 0.1; // Fator de velocidade para dificuldade Extremepower (10x mais r√°pido)
        const ENEMY_CAPTURED_SPEED_MULTIPLIER = 0.5; // Multiplicador para a velocidade do ladr√£o ao capturar um NPC (2x mais r√°pido)

        const DIAMOND_COUNT = 50; // N√∫mero total de diamantes no jogo
        const THIEF_COUNT_NORMAL = 5; // N√∫mero base de ladr√µes para dificuldade Normal
        const THIEF_COUNT_MEDIA = THIEF_COUNT_NORMAL * 2; // Dobro de ladr√µes para dificuldade M√©dia
        const THIEF_COUNT_EXTREMEPOWER = THIEF_COUNT_NORMAL * 4; // Qu√°druplo de ladr√µes para dificuldade Extremepower
        
        // Mapeamento de nomes de NPCs para seus respectivos emojis
        const NPC_EMOJIS = {
            'Gugu': 'üë∂', // Crian√ßa
            'Sekku': 'üç∫', // Copo de chopp
            'Dudu': 'üè†', // Casa
            'Bruno': 'üç´', // Doce de brigadeiro (chocolate)
            '√ârico': 'üë®‚Äçüî¨' // Cientista
        };
        const PLAYER_NAME = 'F√°bio Agent'; // Nome do personagem jog√°vel

        // Constante para limitar as tentativas de posicionamento
        const MAX_PLACEMENT_ATTEMPTS_PER_ENTITY = 500; 

        // Estat√≠sticas do Jogador e Ataques do Drone
        const PLAYER_MAX_HEALTH = 100;
        const DRONE_ATTACKS = {
            vrombulha: { name: 'Vrombulha', damage: 1, cooldown: 1000, currentCooldown: 0, buttonId: 'attack-vrombulha', pbId: 'pb-vrombulha' },
            oinikmask: { name: 'Oinikmask', damage: 3, cooldown: 3000, currentCooldown: 0, buttonId: 'attack-oinikmask', pbId: 'pb-oinikmask' },
            niuciiii: { name: 'Niuciiii', damage: 15, cooldown: 10000, currentCooldown: 0, buttonId: 'attack-niuciiii', pbId: 'pb-niuciiii' },
        };
        const ENEMY_MAX_HEALTH = 10; // Sa√∫de de cada ladr√£o

        // Vari√°veis de Estado do Jogo
        let gamePhase = 'intro'; // Fase atual: 'intro', 'playing', 'battle', 'gameOver'
        let player = { x: 0, y: 0, health: PLAYER_MAX_HEALTH, lastMoveTime: 0 }; // Posi√ß√£o e sa√∫de do jogador
        let enemies = []; // Array para armazenar objetos de ladr√µes {x, y, health, currentSpeed, lastMoveTimestamp}
        let diamonds = []; // Array para armazenar objetos de diamantes {x, y}
        let npcs = []; // Array para armazenar objetos de NPC {x, y, name, emoji, capturedBy: enemy_object || null}
        let map = []; // Array 2D representando o mapa da cidade (0 = Estrada, 1 = Pr√©dio)
        let difficulty = 'normal'; // Configura√ß√£o de dificuldade atual
        let numThievesToPlace = THIEF_COUNT_NORMAL; // N√∫mero de ladr√µes a serem colocados com base na dificuldade

        let currentEnemyInBattle = null; // Refer√™ncia ao inimigo atualmente em batalha
        let animationFrameId = null; // Armazena o ID retornado por requestAnimationFrame para cancelamento

        // Refer√™ncias de Elementos DOM
        const gameIntroScreen = document.getElementById('game-intro');
        const gameScreen = document.getElementById('game-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const gameCanvas = document.getElementById('gameCanvas');
        const ctx = gameCanvas.getContext('2d'); // Contexto de renderiza√ß√£o 2D para o canvas

        const playerHealthDisplay = document.getElementById('player-health');
        const diamondsRemainingDisplay = document.getElementById('diamonds-remaining');
        const enemiesRemainingDisplay = document.getElementById('enemies-remaining');
        const battleScreen = document.getElementById('battle-screen');
        const enemyBattleInfo = document.getElementById('enemy-battle-info');
        const battleMessage = document.getElementById('battle-message');
        const gameMessage = document.getElementById('game-message');
        const gameOverTitle = document.getElementById('game-over-title');
        const gameOverMessage = document.getElementById('game-over-message');
        const battleEnemyEmojiDisplay = document.getElementById('battle-enemy-emoji'); // Refer√™ncia para o emoji do inimigo em batalha

        const restartButton = document.getElementById('restart-button');
        const gameOverRestartButton = document.getElementById('game-over-restart');

        // Definir Dimens√µes do Canvas
        gameCanvas.width = CANVAS_WIDTH;
        gameCanvas.height = CANVAS_HEIGHT;

        /**
         * Inicializa ou redefine o estado do jogo para uma nova rodada.
         */
        function initializeGame() {
            console.log("[Debug] initializeGame() chamado.");
            // Reiniciar jogador, inimigos, diamantes e mapa
            player = { x: 0, y: 0, health: PLAYER_MAX_HEALTH, lastMoveTime: performance.now() }; // Reset player, initialize lastMoveTime
            enemies = []; // Reset enemies
            diamonds = []; // Reset diamonds
            npcs = []; // Reset NPCs
            map = []; // Reset map
            currentEnemyInBattle = null;
            gamePhase = 'playing'; // Definir fase do jogo como 'playing'
            
            // Ocultar mensagens e tela de batalha
            gameMessage.classList.add('hidden');
            battleMessage.classList.add('hidden');
            battleScreen.classList.add('hidden');
            restartButton.classList.add('hidden');

            // Determinar o n√∫mero de ladr√µes com base na dificuldade
            if (difficulty === 'normal') {
                numThievesToPlace = THIEF_COUNT_NORMAL;
            } else if (difficulty === 'media') {
                numThievesToPlace = THIEF_COUNT_MEDIA;
            } else if (difficulty === 'extremepower') {
                numThievesToPlace = THIEF_COUNT_EXTREMEPOWER;
            }

            // Gerar mapa, colocar itens e redefinir UI/ataques
            generateMap();
            placeDiamonds();
            placeEnemies(numThievesToPlace); // Passar o n√∫mero calculado de ladr√µes
            placeNPCs(); // Colocar NPCs ap√≥s mapa, diamantes e inimigos
            resetAttackCooldowns();
            updateUI();

            // Esconder tela de introdu√ß√£o e mostrar tela do jogo
            gameIntroScreen.classList.add('hidden');
            gameScreen.classList.remove('hidden');
            console.log("[Debug] Tela de introdu√ß√£o escondida, tela do jogo mostrada.");


            // Log de depura√ß√£o para verificar o n√∫mero de entidades colocadas
            console.log(`[Debug] Jogo inicializado: Ladr√µes: ${enemies.length}, Diamantes: ${diamonds.length}, NPCs: ${npcs.length}`);

            // Se, por algum motivo, n√£o houver inimigos ou diamantes, avisar e talvez tentar novamente.
            // Para evitar um "Game Over" imediato, vamos apenas avisar no console.
            if (enemies.length === 0) {
                console.warn("[Aviso] N√£o foi poss√≠vel colocar ladr√µes suficientes. O jogo pode ser muito f√°cil ou terminar inesperadamente.");
            }
            if (diamonds.length === 0) {
                console.warn("[Aviso] N√£o foi poss√≠vel colocar diamantes suficientes. O jogo pode terminar em derrota rapidamente.");
            }
            
            startGameLoop(); // Iniciar o loop do jogo
        }

        /**
         * Gera um mapa simples da cidade baseado em grade.
         * Os tiles s√£o atribu√≠dos aleatoriamente como estrada (0) ou edif√≠cio (1).
         * Garante que o tile inicial do jogador seja uma estrada.
         */
        function generateMap() {
            for (let y = 0; y < MAP_HEIGHT; y++) {
                map[y] = [];
                for (let x = 0; x < MAP_WIDTH; x++) {
                    // 25% de chance de um tile de edif√≠cio
                    if (Math.random() < 0.25) {
                        map[y][x] = 1; // Edif√≠cio (n√£o-caminh√°vel)
                    } else {
                        map[y][x] = 0; // Estrada (caminh√°vel)
                    }
                }
            }
            // Garantir que a posi√ß√£o inicial do jogador seja sempre uma estrada
            map[player.y][player.x] = 0;
        }

        /**
         * Coloca diamantes aleatoriamente em tiles caminh√°veis (estrada).
         */
        function placeDiamonds() {
            let placed = 0;
            let attempts = 0;
            const maxTotalAttempts = DIAMOND_COUNT * MAX_PLACEMENT_ATTEMPTS_PER_ENTITY;

            diamonds = []; // Clear previous diamonds
            while (placed < DIAMOND_COUNT && attempts < maxTotalAttempts) {
                const x = Math.floor(Math.random() * MAP_WIDTH);
                const y = Math.floor(Math.random() * MAP_HEIGHT);
                
                // Verificar se o tile √© uma estrada e nenhum diamante j√° estiver l√°
                const isPlayerSpot = (x === player.x && y === player.y);
                const isDiamondSpot = diamonds.some(d => d.x === x && d.y === y);
                // N√£o precisa verificar inimigos/NPCs aqui, pois eles ainda n√£o foram colocados

                if (map[y][x] === 0 && !isPlayerSpot && !isDiamondSpot) {
                    diamonds.push({ x, y });
                    placed++;
                }
                attempts++;
            }
            if (placed < DIAMOND_COUNT) {
                console.warn(`[PlaceDiamonds] N√£o foi poss√≠vel colocar todos os ${DIAMOND_COUNT} diamantes. Colocados: ${placed}.`);
            }
        }

        /**
         * Coloca ladr√µes aleatoriamente em tiles caminh√°veis (estrada),
         * garantindo que eles n√£o apare√ßam sobre o jogador ou diamantes inicialmente.
         * @param {number} count - O n√∫mero de ladr√µes a serem colocados.
         */
        function placeEnemies(count) {
            let placed = 0;
            let attempts = 0;
            const maxTotalAttempts = count * MAX_PLACEMENT_ATTEMPTS_PER_ENTITY;

            let baseSpeedMultiplier;
            if (difficulty === 'normal') {
                baseSpeedMultiplier = ENEMY_SPEED_FACTOR_NORMAL;
            } else if (difficulty === 'media') {
                baseSpeedMultiplier = ENEMY_SPEED_FACTOR_MEDIA;
            } else if (difficulty === 'extremepower') {
                baseSpeedMultiplier = ENEMY_SPEED_FACTOR_EXTREMEPOWER;
            }

            enemies = []; // Limpar inimigos existentes para este posicionamento
            while (placed < count && attempts < maxTotalAttempts) {
                const x = Math.floor(Math.random() * MAP_WIDTH);
                const y = Math.floor(Math.random() * MAP_HEIGHT);
                
                // Verificar se o tile √© uma estrada, n√£o √© a posi√ß√£o do jogador, n√£o √© a posi√ß√£o de um diamante e nenhum outro inimigo est√° l√°
                const isPlayerSpot = (x === player.x && y === player.y);
                const isDiamondSpot = diamonds.some(d => d.x === x && d.y === y);
                const isEnemySpot = enemies.some(e => e.x === x && e.y === y); // Verificar contra inimigos j√° colocados

                if (map[y][x] === 0 && !isPlayerSpot && !isDiamondSpot && !isEnemySpot) {
                    enemies.push({ 
                        x, 
                        y, 
                        health: ENEMY_MAX_HEALTH,
                        currentSpeed: ENEMY_BASE_MOVE_DELAY_MS * baseSpeedMultiplier, // Velocidade inicial baseada na dificuldade
                        lastMoveTimestamp: performance.now(),
                        isCarryingNpc: false // Novo: Flag para indicar se o ladr√£o est√° carregando um NPC
                    });
                    placed++;
                }
                attempts++;
            }
            if (placed < count) {
                console.warn(`[PlaceEnemies] N√£o foi poss√≠vel colocar todos os ${count} ladr√µes. Colocados: ${placed}.`);
            }
        }

        /**
         * Coloca NPCs aleatoriamente em tiles caminh√°veis (estrada),
         * garantindo que eles n√£o apare√ßam sobre o jogador, inimigos ou diamantes.
         */
        function placeNPCs() {
            npcs = []; // Limpar NPCs existentes
            let placed = 0;
            let attempts = 0;
            const maxTotalAttempts = Object.keys(NPC_EMOJIS).length * MAX_PLACEMENT_ATTEMPTS_PER_ENTITY; // Usar o n√∫mero de NPCs definido pelo mapeamento

            for (const name in NPC_EMOJIS) {
                let npcPlaced = false;
                let npcAttempts = 0;
                while (!npcPlaced && npcAttempts < MAX_PLACEMENT_ATTEMPTS_PER_ENTITY) {
                    const x = Math.floor(Math.random() * MAP_WIDTH);
                    const y = Math.floor(Math.random() * MAP_HEIGHT);
                    
                    // Verificar se o tile √© uma estrada, n√£o √© a posi√ß√£o do jogador, n√£o √© a posi√ß√£o de um diamante, n√£o √© a posi√ß√£o de um inimigo e n√£o √© a posi√ß√£o de outro NPC
                    const isPlayerSpot = (x === player.x && y === player.y);
                    const isDiamondSpot = diamonds.some(d => d.x === x && d.y === y);
                    const isEnemySpot = enemies.some(e => e.x === x && e.y === y);
                    const isNpcSpot = npcs.some(n => n.x === x && n.y === y);

                    if (map[y][x] === 0 && !isPlayerSpot && !isDiamondSpot && !isEnemySpot && !isNpcSpot) {
                        npcs.push({ x, y, name, emoji: NPC_EMOJIS[name], capturedBy: null }); // Adicionar o emoji espec√≠fico
                        npcPlaced = true;
                        placed++;
                    }
                    npcAttempts++;
                    attempts++;
                }
            }
            if (placed < Object.keys(NPC_EMOJIS).length) {
                console.warn(`[PlaceNPCs] N√£o foi poss√≠vel colocar todos os ${Object.keys(NPC_EMOJIS).length} NPCs. Colocados: ${placed}.`);
            }
        }


        /**
         * Redefine todos os tempos de recarga dos ataques do drone e habilita os bot√µes de ataque.
         */
        function resetAttackCooldowns() {
            for (const key in DRONE_ATTACKS) {
                DRONE_ATTACKS[key].currentCooldown = 0;
                DRONE_ATTACKS[key].lastUpdateTimestamp = 0; // Reset timestamp for cooldowns
                updateProgressBar(DRONE_ATTACKS[key]);
                document.getElementById(DRONE_ATTACKS[key].buttonId).disabled = false;
            }
        }

        /**
         * Atualiza as exibi√ß√µes de sa√∫de, diamantes e contagem de inimigos.
         */
        function updateUI() {
            playerHealthDisplay.textContent = `HP F√°bio: ${player.health}`;
            diamondsRemainingDisplay.textContent = `Diamantes Restantes: ${diamonds.length}`;
            enemiesRemainingDisplay.textContent = `Ladr√µes Restantes: ${enemies.length}`;

            // Atualizar exibi√ß√£o de sa√∫de do inimigo durante a batalha
            if (gamePhase === 'battle' && currentEnemyInBattle) {
                enemyBattleInfo.textContent = `Ladr√£o HP: ${currentEnemyInBattle.health}`;
            }
        }

        /**
         * Desenha todos os elementos do jogo no canvas.
         */
        function draw() {
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT); // Limpar todo o canvas

            // Desenhar tiles do mapa
            for (let y = 0; y < MAP_HEIGHT; y++) {
                for (let x = 0; x < MAP_WIDTH; x++) {
                    if (map[y][x] === 0) { // Tile de estrada
                        ctx.fillStyle = '#4a5568'; // Cinza escuro
                    } else { // Tile de edif√≠cio
                        ctx.fillStyle = '#2d3748'; // Cinza mais escuro
                    }
                    ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE); // Desenhar o ret√¢ngulo preenchido
                    ctx.strokeStyle = '#2d3748'; // Cor da linha da grade
                    ctx.strokeRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE); // Desenhar linhas da grade
                }
            }

            // Desenhar diamantes como emoji
            ctx.font = `${TILE_SIZE * 0.8}px 'Segoe UI Emoji', 'Apple Color Emoji', 'Segoe UI Symbol', 'Noto Color Emoji', sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            diamonds.forEach(d => {
                ctx.fillText('üíé', d.x * TILE_SIZE + TILE_SIZE / 2, d.y * TILE_SIZE + TILE_SIZE / 2);
            });

            // Desenhar ladr√µes como emoji
            enemies.forEach(e => {
                ctx.fillText('ü¶π', e.x * TILE_SIZE + TILE_SIZE / 2, e.y * TILE_SIZE + TILE_SIZE / 2);
            });

            // Desenhar NPCs como emoji e nome
            npcs.forEach(npc => {
                let displayX = npc.x;
                let displayY = npc.y;
                let displayEmoji = npc.emoji; // Usar o emoji espec√≠fico do NPC

                if (npc.capturedBy) {
                    // Se capturado, desenhe o NPC na posi√ß√£o do ladr√£o
                    displayX = npc.capturedBy.x;
                    displayY = npc.capturedBy.y;
                }
                
                ctx.font = `${TILE_SIZE * 0.8}px 'Segoe UI Emoji', 'Apple Color Emoji', 'Segoe UI Symbol', 'Noto Color Emoji', sans-serif`; // Reset font for emoji
                ctx.fillText(displayEmoji, displayX * TILE_SIZE + TILE_SIZE / 2, displayY * TILE_SIZE + TILE_SIZE / 2 - TILE_SIZE * 0.15); // Adjust Y for emoji

                ctx.font = `${TILE_SIZE * 0.3}px 'Inter', sans-serif`; // Smaller font for name
                ctx.fillStyle = '#e2e8f0'; // Light text color
                ctx.fillText(npc.name, displayX * TILE_SIZE + TILE_SIZE / 2, displayY * TILE_SIZE + TILE_SIZE / 2 + TILE_SIZE * 0.3); // Draw name below emoji
            });

            // Desenhar jogador como emoji e nome
            ctx.font = `${TILE_SIZE * 0.8}px 'Segoe UI Emoji', 'Apple Color Emoji', 'Segoe UI Symbol', 'Noto Color Emoji', sans-serif`; // Redefinir fonte para emoji
            ctx.fillText('üëÆ', player.x * TILE_SIZE + TILE_SIZE / 2, player.y * TILE_SIZE + TILE_SIZE / 2 - TILE_SIZE * 0.15); // Ajustar Y para emoji
            ctx.font = `${TILE_SIZE * 0.3}px 'Inter', sans-serif`; // Fonte menor para o nome
            ctx.fillStyle = '#e2e8f0'; // Cor do texto claro
            ctx.fillText(PLAYER_NAME, player.x * TILE_SIZE + TILE_SIZE / 2, player.y * TILE_SIZE + TILE_SIZE / 2 + TILE_SIZE * 0.3); // Desenhar nome abaixo do emoji
        }

        /**
         * O loop principal do jogo. Esta fun√ß√£o √© chamada repetidamente por requestAnimationFrame.
         * @param {DOMHighResTimeStamp} timestamp - O tempo atual fornecido por requestAnimationFrame.
         */
        function gameLoop(timestamp) {
            if (gamePhase === 'playing') {
                // Lidar com o movimento dos inimigos com base em sua velocidade individual
                enemies.forEach(enemy => {
                    if (timestamp - enemy.lastMoveTimestamp > enemy.currentSpeed) {
                        moveEnemy(enemy, timestamp); // Mover inimigo individualmente
                        enemy.lastMoveTimestamp = timestamp; // Atualizar o timestamp do √∫ltimo movimento
                    }
                });
            } else if (gamePhase === 'battle') {
                // Atualizar tempos de recarga para ataques do drone durante a batalha
                for (const key in DRONE_ATTACKS) {
                    const attack = DRONE_ATTACKS[key];
                    if (attack.currentCooldown > 0) {
                        // Reduzir o tempo de recarga com base no tempo decorrido
                        attack.currentCooldown = Math.max(0, attack.currentCooldown - (timestamp - (attack.lastUpdateTimestamp || timestamp)));
                        attack.lastUpdateTimestamp = timestamp; // Armazenar o timestamp da √∫ltima atualiza√ß√£o
                        updateProgressBar(attack); // Atualizar barra de progresso visual
                        // Desabilitar bot√£o se ainda estiver em tempo de recarga
                        document.getElementById(attack.buttonId).disabled = attack.currentCooldown > 0;
                    } else {
                        // Se n√£o estiver em cooldown, garantir que o bot√£o esteja habilitado
                        document.getElementById(attack.buttonId).disabled = false;
                    }
                }
            }

            draw(); // Redesenhar todos os elementos do jogo
            animationFrameId = requestAnimationFrame(gameLoop); // Solicitar o pr√≥ximo frame de anima√ß√£o
        }

        /**
         * Inicia o loop principal do jogo, garantindo que apenas um loop esteja ativo.
         */
        function startGameLoop() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId); // Cancelar qualquer loop existente
            }
            // Inicializar o timestamp do √∫ltimo movimento para cada inimigo
            enemies.forEach(enemy => {
                enemy.lastMoveTimestamp = performance.now();
            });
            // Definir o lastMoveTime do jogador ao iniciar o jogo para evitar movimento imediato
            player.lastMoveTime = performance.now(); 

            animationFrameId = requestAnimationFrame(gameLoop); // Iniciar o novo loop
        }

        /**
         * Para o loop principal do jogo.
         */
        function stopGameLoop() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId); // Cancelar a solicita√ß√£o do frame de anima√ß√£o
                animationFrameId = null;
            }
        }

        /**
         * Lida com o movimento do jogador com base na entrada das teclas de seta do teclado.
         */
        document.addEventListener('keydown', (e) => {
            if (gamePhase !== 'playing') return; // Permitir movimento apenas na fase 'playing'

            const now = performance.now();
            // Evitar movimentos r√°pidos consecutivos dentro do intervalo PLAYER_SPEED_MS
            if (now - player.lastMoveTime < PLAYER_SPEED_MS) return;

            let newX = player.x;
            let newY = player.y;

            // Determinar novas coordenadas com base na tecla de seta pressionada
            if (e.key === 'ArrowUp') newY--;
            else if (e.key === 'ArrowDown') newY++;
            else if (e.key === 'ArrowLeft') newX--;
            else if (e.key === 'ArrowRight') newX++;
            else return; // Ignorar teclas que n√£o sejam de movimento

            // Verificar se a nova posi√ß√£o est√° dentro dos limites do mapa
            if (newX >= 0 && newX < MAP_WIDTH && newY >= 0 && newY < MAP_HEIGHT) {
                // Verificar se o tile de destino √© caminh√°vel (n√£o um edif√≠cio)
                if (map[newY][newX] === 0) {
                    player.x = newX; // Atualizar coordenada x do jogador
                    player.y = newY; // Atualizar coordenada y do jogador
                    player.lastMoveTime = now; // Atualizar o tempo do √∫ltimo movimento
                    checkEncounters(); // Verificar batalhas ap√≥s o movimento
                    draw(); // Redesenhar a cena do jogo imediatamente
                }
            }
        });

        /**
         * Verifica se o jogador se moveu para o mesmo tile que um inimigo.
         * Se sim, inicia uma batalha.
         */
        function checkEncounters() {
            for (let i = 0; i < enemies.length; i++) {
                if (player.x === enemies[i].x && player.y === enemies[i].y) {
                    startBattle(enemies[i]); // Iniciar batalha com o inimigo encontrado
                    return; // Sair ap√≥s encontrar o primeiro encontro
                }
            }
            checkWinCondition(); // Verificar condi√ß√£o de vit√≥ria ap√≥s o jogador se mover e nenhuma batalha come√ßar
        }

        /**
         * Move um inimigo individual em dire√ß√£o ao diamante mais pr√≥ximo,
         * evitando paredes e outros inimigos, e lida com a captura de NPCs.
         * @param {object} enemy - O objeto inimigo a ser movido.
         * @param {DOMHighResTimeStamp} timestamp - O tempo atual.
         */
        function moveEnemy(enemy, timestamp) {
            let currentX = enemy.x;
            let currentY = enemy.y;
            let newX = currentX;
            let newY = currentY;
            let moved = false;

            let targetDiamond = null;
            if (diamonds.length > 0) {
                // Encontrar o diamante mais pr√≥ximo para o inimigo atual
                let minDist = Infinity;
                diamonds.forEach(diamond => {
                    const dist = Math.abs(currentX - diamond.x) + Math.abs(currentY - diamond.y);
                    if (dist < minDist) {
                        minDist = dist;
                        targetDiamond = diamond;
                    }
                });
            }

            // Definir dire√ß√µes de movimento poss√≠veis (dx, dy)
            const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]; // Baixo, Cima, Direita, Esquerda

            let validMoves = [];

            // Avaliar cada dire√ß√£o poss√≠vel
            for (let dir of directions) {
                const testX = currentX + dir[0];
                const testY = currentY + dir[1];

                // Verificar se a potencial nova posi√ß√£o est√° dentro dos limites do mapa e √© um tile caminh√°vel (estrada)
                if (testX >= 0 && testX < MAP_WIDTH && testY >= 0 && testY < MAP_HEIGHT &&
                    map[testY][testX] === 0) {
                    // Verificar se a posi√ß√£o potencial n√£o est√° ocupada pelo jogador ou por outro ladr√£o
                    if (!(testX === player.x && testY === player.y)) {
                        let isBlockedByAnotherThief = false;
                        for (let otherEnemy of enemies) {
                            if (otherEnemy !== enemy && otherEnemy.x === testX && otherEnemy.y === testY) {
                                isBlockedByAnotherThief = true;
                                break;
                            }
                        }
                        
                        // Permitir que o ladr√£o se mova para a posi√ß√£o de um NPC n√£o capturado para peg√°-lo
                        // N√£o h√° mais necessidade de verificar NPCs aqui como "bloqueio"
                        
                        if (!isBlockedByAnotherThief) {
                            // Este √© um movimento v√°lido, pois n√£o est√° bloqueado por jogador ou outro ladr√£o.
                            validMoves.push({ x: testX, y: testY, dirX: dir[0], dirY: dir[1] });
                        }
                    }
                }
            }

            // Classificar movimentos v√°lidos com base na desejabilidade
            if (validMoves.length > 0) {
                if (targetDiamond) {
                    // Classificar pela dist√¢ncia de Manhattan para o diamante alvo (crescente)
                    validMoves.sort((a, b) => {
                        const distA = Math.abs(a.x - targetDiamond.x) + Math.abs(a.y - targetDiamond.y);
                        const distB = Math.abs(b.x - targetDiamond.x) + Math.abs(b.y - targetDiamond.y);
                        return distA - distB;
                    });

                    // Filtrar para movimentos que atingem a dist√¢ncia m√≠nima
                    const minDistance = Math.abs(validMoves[0].x - targetDiamond.x) + Math.abs(validMoves[0].y - targetDiamond.y);
                    const bestMoves = validMoves.filter(move => {
                        return (Math.abs(move.x - targetDiamond.x) + Math.abs(move.y - targetDiamond.y)) === minDistance;
                    });

                    // Escolher aleatoriamente um dos melhores movimentos para introduzir variedade
                    const chosenMove = bestMoves[Math.floor(Math.random() * bestMoves.length)];
                    newX = chosenMove.x;
                    newY = chosenMove.y;
                    moved = true;
                } else {
                    // Se n√£o houver diamantes restantes, escolher um movimento aleat√≥rio v√°lido para continuar se movendo
                    const randomMove = validMoves[Math.floor(Math.random() * validMoves.length)];
                    newX = randomMove.x;
                    newY = randomMove.y;
                    moved = true;
                }
            }

            if (moved) {
                enemy.x = newX;
                enemy.y = newY;
                checkDiamondCollection(enemy); // Verificar coleta de diamantes

                // Verificar captura de NPC ap√≥s o movimento do inimigo
                const capturedNpc = npcs.find(npc => npc.x === enemy.x && npc.y === enemy.y && !npc.capturedBy);
                if (capturedNpc) {
                    capturedNpc.capturedBy = enemy; // Atribuir o ladr√£o como captor
                    enemy.isCarryingNpc = true; // Marcar o ladr√£o como carregando um NPC
                    
                    // Definir a nova velocidade do ladr√£o capturador
                    let baseSpeedMultiplier;
                    if (difficulty === 'normal') {
                        baseSpeedMultiplier = ENEMY_SPEED_FACTOR_NORMAL;
                    } else if (difficulty === 'media') {
                        baseSpeedMultiplier = ENEMY_SPEED_FACTOR_MEDIA;
                    } else if (difficulty === 'extremepower') {
                        baseSpeedMultiplier = ENEMY_SPEED_FACTOR_EXTREMEPOWER;
                    }
                    enemy.currentSpeed = ENEMY_BASE_MOVE_DELAY_MS * baseSpeedMultiplier * ENEMY_CAPTURED_SPEED_MULTIPLIER;
                    
                    showMessage(`${capturedNpc.name} foi capturado por um ladr√£o e ele ficou MAIS R√ÅPIDO!`, 'danger');
                }
            }

            // Atualizar posi√ß√µes dos NPCs j√° capturados
            npcs.forEach(npc => {
                if (npc.capturedBy === enemy) { // Se este inimigo capturou este NPC
                    npc.x = enemy.x;
                    npc.y = enemy.y;
                }
            });
        }


        /**
         * Verifica se um inimigo se moveu para a posi√ß√£o de um diamante.
         * Se sim, o diamante √© "coletado" (removido do jogo).
         * @param {object} enemy - O objeto inimigo que acabou de se mover.
         */
        function checkDiamondCollection(enemy) {
            const diamondIndex = diamonds.findIndex(d => d.x === enemy.x && d.y === enemy.y);
            if (diamondIndex !== -1) {
                diamonds.splice(diamondIndex, 1); // Remover o diamante coletado
                updateUI(); // Atualizar UI para refletir menos diamantes
                showMessage(`Um ladr√£o pegou um diamante!`, 'danger'); // Notificar o jogador
                checkLoseCondition(); // Verificar se todos os diamantes se foram (condi√ß√£o de derrota)
            }
        }

        /**
         * Transiciona o jogo para o modo de batalha.
         * @param {object} enemy - O objeto inimigo com o qual F√°bio Agent est√° lutando.
         */
        function startBattle(enemy) {
            gamePhase = 'battle'; // Mudar a fase do jogo para batalha
            currentEnemyInBattle = enemy; // Definir o inimigo atual em batalha
            battleScreen.classList.remove('hidden'); // Mostrar a UI de batalha
            gameCanvas.classList.add('hidden'); // Ocultar o canvas do mapa durante a batalha
            showMessage(`Ladr√£o encontrado! Preparar para a batalha!`, 'info'); // Exibir mensagem de in√≠cio de batalha
            updateUI(); // Atualizar UI para mostrar a sa√∫de do inimigo
            resetAttackCooldowns(); // Redefinir tempos de recarga dos ataques do drone para a batalha
        }

        /**
         * Termina a batalha atual e retorna o jogo para o modo de mapa.
         */
        function endBattle() {
            gamePhase = 'playing'; // Mudar a fase do jogo de volta para 'playing'
            currentEnemyInBattle = null; // Limpar o inimigo atual em batalha
            battleScreen.classList.add('hidden'); // Ocultar a UI de batalha
            gameCanvas.classList.remove('hidden'); // Mostrar o canvas do mapa
            showMessage(`Batalha vencida!`, 'success'); // Exibir mensagem de batalha vencida
            checkWinCondition(); // Verificar se todos os inimigos foram derrotados (condi√ß√£o de vit√≥ria)
            draw(); // Redesenhar o mapa para refletir as mudan√ßas (ex: inimigo removido)
        }

        /**
         * Executa um ataque de drone durante a batalha.
         * @param {object} attack - O objeto de ataque do drone (ex: DRONE_ATTACKS.vrombulha).
         */
        function performAttack(attack) {
            // Prevenir ataque se n√£o estiver em batalha, sem inimigo ou ataque estiver em tempo de recarga
            if (gamePhase !== 'battle' || !currentEnemyInBattle || attack.currentCooldown > 0) return;

            // Aplicar dano ao inimigo atual
            currentEnemyInBattle.health -= attack.damage;
            showMessage(`Seu drone usou ${attack.name} e causou ${attack.damage} de dano!`, 'success');
            updateUI(); // Atualizar exibi√ß√£o de sa√∫de do inimigo

            // Definir o tempo de recarga para o ataque usado
            attack.currentCooldown = attack.cooldown;
            attack.lastUpdateTimestamp = performance.now(); // Gravar o timestamp de in√≠cio do cooldown
            updateProgressBar(attack); // Atualizar barra de progresso visual
            document.getElementById(attack.buttonId).disabled = true; // Desabilitar bot√£o durante o tempo de recarga

            // Verificar se o inimigo foi derrotado
            if (currentEnemyInBattle.health <= 0) {
                showMessage(`Ladr√£o eliminado!`, 'success');

                // Liberar qualquer NPC capturado e resetar a velocidade do ladr√£o
                npcs.forEach(npc => {
                    if (npc.capturedBy === currentEnemyInBattle) {
                        npc.capturedBy = null; // Liberar o NPC
                        // Restaurar a velocidade do ladr√£o (se ele ainda existisse e fosse um caso de m√∫ltiplos NPCs)
                        currentEnemyInBattle.isCarryingNpc = false;
                        
                        let baseSpeedMultiplier;
                        if (difficulty === 'normal') {
                            baseSpeedMultiplier = ENEMY_SPEED_FACTOR_NORMAL;
                        } else if (difficulty === 'media') {
                            baseSpeedMultiplier = ENEMY_SPEED_FACTOR_MEDIA;
                        } else if (difficulty === 'extremepower') {
                            baseSpeedMultiplier = ENEMY_SPEED_FACTOR_EXTREMEPOWER;
                        }
                        currentEnemyInBattle.currentSpeed = ENEMY_BASE_MOVE_DELAY_MS * baseSpeedMultiplier;

                        // Encontrar um novo local seguro para o NPC resgatado
                        let newNpcX, newNpcY;
                        let placedNpc = false;
                        let npcAttempts = 0;
                        const maxNpcAttempts = 100; // Tentativas para colocar NPC

                        while (!placedNpc && npcAttempts < maxNpcAttempts) {
                            newNpcX = Math.floor(Math.random() * MAP_WIDTH);
                            newNpcY = Math.floor(Math.random() * MAP_HEIGHT);
                            // Verificar se o tile √© uma estrada, n√£o √© a posi√ß√£o do jogador, n√£o √© a posi√ß√£o de um diamante e n√£o est√° ocupado por nenhum inimigo ou outro NPC
                            if (map[newNpcY][newNpcX] === 0 && !(newNpcX === player.x && newNpcY === player.y) &&
                                !diamonds.some(d => d.x === newNpcX && d.y === newNpcY) &&
                                !enemies.some(e => e.x === newNpcX && e.y === newNpcY) && // Verifica contra inimigos remanescentes
                                !npcs.some(n => n !== npc && n.x === newNpcX && n.y === newNpcY)) { // Verifica contra outros NPCs
                                npc.x = newNpcX;
                                npc.y = newNpcY;
                                placedNpc = true;
                            }
                            npcAttempts++;
                        }
                        if (!placedNpc) {
                            console.warn(`[Resgate NPC] N√£o foi poss√≠vel encontrar um local seguro para ${npc.name}.`);
                        }
                        showMessage(`${npc.name} foi salvo!`, 'info');
                    }
                });

                // Remover o inimigo derrotado do array de inimigos
                enemies = enemies.filter(e => e !== currentEnemyInBattle);
                setTimeout(endBattle, 1500); // Esperar um pouco pela mensagem e depois terminar a batalha
            } else {
                // Se o inimigo n√£o for derrotado, ele revida (simples: causa 1 de dano ao jogador)
                player.health -= 1;
                showMessage(`O ladr√£o contra-atacou! F√°bio perdeu 1 HP.`, 'danger');
                updateUI(); // Atualizar exibi√ß√£o de sa√∫de do jogador
                checkLoseCondition(); // Verificar se o jogador foi derrotado (condi√ß√£o de derrota)
            }
        }

        /**
         * Atualiza a barra de progresso visual para o tempo de recarga de um ataque.
         * @param {object} attack - O objeto de ataque com `cooldown`, `currentCooldown` e `pbId`.
         */
        function updateProgressBar(attack) {
            const progressBar = document.getElementById(attack.pbId);
            if (progressBar) {
                // Calcular o progresso como uma porcentagem
                const progress = ((attack.cooldown - attack.currentCooldown) / attack.cooldown) * 100;
                progressBar.style.width = `${progress}%`; // Definir a largura da barra de progresso
            }
        }

        /**
         * Verifica se o jogador venceu o jogo (todos os ladr√µes eliminados).
         * Se venceu, transiciona para a tela de fim de jogo com uma mensagem de vit√≥ria.
         */
        function checkWinCondition() {
            if (enemies.length === 0) {
                stopGameLoop(); // Parar o loop do jogo
                gamePhase = 'gameOver'; // Definir a fase do jogo como 'gameOver'
                gameScreen.classList.add('hidden'); // Ocultar a tela principal do jogo
                gameOverScreen.classList.remove('hidden'); // Mostrar a tela de fim de jogo
                gameOverTitle.textContent = 'VIT√ìRIA!'; // Definir t√≠tulo de vit√≥ria
                gameOverTitle.classList.remove('text-red-500'); // Remover cor vermelha
                gameOverTitle.classList.add('text-green-500'); // Adicionar cor verde
                gameOverMessage.textContent = 'Todos os ladr√µes foram eliminados! A cidade est√° segura!'; // Definir mensagem de vit√≥ria
                restartButton.classList.remove('hidden'); // Mostrar bot√£o de reiniciar tamb√©m na tela principal (para conveni√™ncia)
            }
        }

        /**
         * Verifica se o jogador perdeu o jogo (todos os diamantes coletados ou sa√∫de do jogador √© zero).
         * Se perdeu, transiciona para a tela de fim de jogo com uma mensagem de derrota.
         */
        function checkLoseCondition() {
            if (diamonds.length === 0 || player.health <= 0) {
                stopGameLoop(); // Parar o loop do jogo
                gamePhase = 'gameOver'; // Definir a fase do jogo como 'gameOver'
                gameScreen.classList.add('hidden'); // Ocultar a tela principal do jogo
                gameOverScreen.classList.remove('hidden'); // Mostrar a tela de fim de jogo
                gameOverTitle.textContent = 'GAME OVER!'; // Definir t√≠tulo de fim de jogo
                gameOverTitle.classList.remove('text-green-500'); // Remover cor verde
                gameOverTitle.classList.add('text-red-500'); // Adicionar cor vermelha
                // Definir mensagem de derrota espec√≠fica com base na causa
                if (diamonds.length === 0) {
                    gameOverMessage.textContent = 'Os ladr√µes levaram todos os diamantes!';
                } else {
                    gameOverMessage.textContent = 'F√°bio Agent foi derrotado!';
                }
                restartButton.classList.remove('hidden'); // Mostrar bot√£o de reiniciar
            }
        }

        /**
         * Exibe uma caixa de mensagem tempor√°ria na tela.
         * @param {string} message - O conte√∫do do texto da mensagem.
         * @param {string} type - O tipo de mensagem ('info', 'success', 'danger') para estiliza√ß√£o.
         */
        function showMessage(message, type) {
            // Determinar qual elemento de mensagem usar (batalha ou mensagem geral do jogo)
            const targetMessageElement = gamePhase === 'battle' ? battleMessage : gameMessage;
            targetMessageElement.textContent = message; // Definir texto da mensagem
            // Remover classes de tipo anteriores e mostrar a caixa de mensagem
            targetMessageElement.classList.remove('hidden', 'bg-blue-600', 'bg-green-600', 'bg-red-600');
            // Adicionar cor de fundo apropriada com base no tipo de mensagem
            if (type === 'info') targetMessageElement.classList.add('bg-blue-600');
            else if (type === 'success') targetMessageElement.classList.add('bg-green-600');
            else if (type === 'danger') targetMessageElement.classList.add('bg-red-600');
            else targetMessageElement.classList.add('bg-gray-600'); // Cinza padr√£o

            // Ocultar a mensagem ap√≥s um atraso
            setTimeout(() => {
                targetMessageElement.classList.add('hidden');
            }, 3000); // A mensagem desaparece ap√≥s 3 segundos
        }

        // --- Event Listeners ---

        // Event Listeners para bot√µes de Sele√ß√£o de Dificuldade
        document.getElementById('difficulty-normal').addEventListener('click', () => {
            console.log("[Debug] Bot√£o NORMAL clicado.");
            difficulty = 'normal'; // Definir dificuldade
            initializeGame(); // Iniciar o jogo
        });
        document.getElementById('difficulty-media').addEventListener('click', () => {
            console.log("[Debug] Bot√£o M√âDIA clicado.");
            difficulty = 'media';
            initializeGame();
        });
        document.getElementById('difficulty-extremepower').addEventListener('click', () => {
            console.log("[Debug] Bot√£o EXTREMEPOWER clicado.");
            difficulty = 'extremepower';
            initializeGame();
        });

        // Event Listeners para bot√µes de Ataque do Drone em Batalha
        document.getElementById(DRONE_ATTACKS.vrombulha.buttonId).addEventListener('click', () => performAttack(DRONE_ATTACKS.vrombulha));
        document.getElementById(DRONE_ATTACKS.oinikmask.buttonId).addEventListener('click', () => performAttack(DRONE_ATTACKS.oinikmask));
        document.getElementById(DRONE_ATTACKS.niuciiii.buttonId).addEventListener('click', () => performAttack(DRONE_ATTACKS.niuciiii));

        // Bot√µes de reiniciar da tela principal do jogo e da tela de fim de jogo
        restartButton.addEventListener('click', () => {
            console.log("[Debug] Bot√£o Reiniciar Jogo clicado.");
            gameScreen.classList.add('hidden'); // Ocultar tela do jogo
            gameIntroScreen.classList.remove('hidden'); // Mostrar tela de introdu√ß√£o
            stopGameLoop(); // Parar o loop do jogo
        });
        gameOverRestartButton.addEventListener('click', () => {
            console.log("[Debug] Bot√£o Jogar Novamente clicado na tela Game Over.");
            gameOverScreen.classList.add('hidden'); // Ocultar tela de fim de jogo
            gameIntroScreen.classList.remove('hidden'); // Mostrar tela de introdu√ß√£o
            stopGameLoop(); // Parar o loop do jogo
        });

        // Configura√ß√£o inicial para barras de progresso (para mostr√°-las vazias)
        for (const key in DRONE_ATTACKS) {
            updateProgressBar(DRONE_ATTACKS[key]);
        }

        // O jogo come√ßa exibindo a tela de introdu√ß√£o.
        // O usu√°rio deve selecionar uma dificuldade para come√ßar a jogar.
    </script>
</body>
</html>

